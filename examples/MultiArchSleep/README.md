# マルチCPUアーキテクチャ対応，スリープとwakeupのサンプルプログラム

本サンプルプログラムは，AVR，SAMD，ESP32，ESP8266のCPUに対応したスリープとそこからの復帰を行う処理を，1つのプログラムで実装する事例になっています．

以下，このサンプルプログラムを読み解く上で参考になる情報を記します．

## ESP32でEXT1割り込みを利用する設定
ESP32でEXT0ではなく，EXT1割り込みを使う場合，以下のコメントアウト部分されている部分を生かしたください．その際，EXT1で監視するピン番号を数値で指定してください．ESP32以外の機種，ESP32でEXT1割り込みを使わない場合は下の行を生かしてください．
```
//#define PIN_MASK 0b100000000000000  // ESP32でEXT1割り込みを使う場合の設定 ピン番号 IO14
#define PIN_MASK 0 
```

## ピン番号の指定
ESP32以外の機種を利用する場合は，スイッチ等の操作でsleepから起こす場合に，スイッチを接続するピン番号を指定する必要があります．そのための定数を定義します．下の例はデジタルピンの0番にスイッチ等を接続する例になっています．

## CPUの識別

本ライブラリでは，内部で[detectArduinoHardware]を使っています．サンプルプログラムでも，[detectArduinoHardware]の機能を利用して，CPUアーキで定数の定義を変えています．
```
#if CPU_ARCH==AVR_ARCH /* AVR */
```

## 機種毎に異なる情報の定義
定義するべき定数は以下の3種類です．
| 定数 | 内容 |
|---|---|
| PIN_NUMBER | (ESP8266以外) スイッチを接続するピン番号 |
| WIRELESS_STATUS | (ESP8266限定) スリープ中のWiFI回路の状態 |
| MAX_DURATION | (AVR以外) 一定時間でスリープから復帰する場合の眠る時間 |

CPUアーキテクチャにより，各定数がsleepで意味を持たないものもありますが，定義しておくことでプログラム本体の中で``#ifdef``などで切り替える必要がなくなります．AVRはsleepから時間経過で自動的に復帰する機能はありませんが，``int sleepMode = helper.SetSleepMode(mode, MAX_DURATION);``のように第2引数が0であることを期待したAPIの動作になるため，``MAX_DURATION``を``0``にしておきます．

同様に，``PIN_NUMBER``や``WIRELESS_STATUS``もCPUが対応する機能を持たない場合であっても，定義しておくことで，プログラム本体の中で``#ifdef``を使って切り替える必要がなくなります．

## CPUの種類による処理の切り替え
```
int cpuArch=CPU_ARCH;
```
本ライブラリが内部で利用している[detectArduinoHardware]の機能を使い，上のようなグローバル変数を1つ定義することで，下の例のようにCPUアーキにより処理を切り替えている．
```
if (cpuArch==XTENSA_LX106_ARCH) {/*  ESP32の場合の処理 */}
```

## 対応しているスリープモードの判定
関数``int SelectSleepMode()``の中で以下のような処理がある．
```
    if (helper.checkSleepMode(MODE_IDLE)) {
      Serial.println("Idle mode       : \"i\" ");
    }
```
この処理は，CPUがsleepの動作モードとして``MODE_IDLE``をサポートしている場合だけ，シリアルへの出力が実行される．本ライブラリの``checkSleepMode()``によりCPUが引数で与えられた動作モードをサポートしているか否かを``bool``で返すので，これを利用している．

## sleepから復帰した理由の判断
sleepからの復帰理由の判定は``void outputIntInfo(void)``で行われています．
ESP8266は復帰時にリセットと同じ動作になり，理由の判定はできません．そのため，``void outputIntInfo(void)``の冒頭で
CPUがESP8266の場合は即座に関数の処理を終了しています．

ESP8266以外のCPUでは，``int32_t reason=helper.WakeUpReason();``で復帰理由を取得し，その次の``switch(reason)``で復帰理由で処理を切り替えています．

本ライブラリの``WakeUpReason()``は，ESP32の場合に下8bitを使って，復帰理由を格納して返します．
一方，ESP32(とESP8266)以外のCPUの場合は，上位24bitに復帰理由(複数が該当する可能性がある)が2bitの値で格納されます．そのため，先程の``switch``文の末尾の``default``部分がこれに相当します．

## 割り込みの定義
sleepからの復帰で利用される割り込みの定義は``void setupInterrupt()``の内部で行われています．特定のCPUアーキテクチャでしか意味のない処理は``if (cpuArch==XTENSA_LX6_ARCH)``で切り替えを行っていますが，本ライブラリでは意味の無いAPIが呼ばれた場合は「サポートしていない関数」を意味するエラーコードを返し，何もしないため，もし実行された場合でも影響はありません．



